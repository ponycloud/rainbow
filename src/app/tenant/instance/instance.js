// Generated by CoffeeScript 1.7.1
(function() {
  var InstanceDetailCtrl, InstanceListCtrl, InstanceWizardCtrl, module,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  module = angular.module('tenantInstance', ['rainbowServices']);

  module.config([
    '$routeProvider', function($routeProvider) {
      $routeProvider.when('/:tenant/instance', {
        templateUrl: 'tenant/instance/instance-list.tpl.html',
        controller: 'InstanceListCtrl'
      });
      $routeProvider.when('/:tenant/instance/create', {
        templateUrl: 'tenant/instance/instance-wizard.tpl.html',
        controller: 'InstanceWizardCtrl'
      });
      return $routeProvider.when('/:tenant/instance/:instance', {
        templateUrl: 'tenant/instance/instance-detail.tpl.html',
        controller: 'InstanceDetailCtrl'
      });
    }
  ]);

  module.controller('InstanceListCtrl', InstanceListCtrl = (function() {
    InstanceListCtrl.inject = ['$scope', '$routeParams', 'TenantInstance', 'dataContainer'];

    function InstanceListCtrl($scope, $routeParams, TenantInstance, dataContainer, $modal) {
      var list;
      list = TenantInstance.list({
        tenant: $routeParams.tenant
      });
      list.$promise.then(function(i) {
        $scope.instances = i;
        return dataContainer.registerEntity('instance', $scope.instances);
      });
      $scope.setStateSelected = function(selected, state) {
        var item, params, patch, _i, _len;
        params = {
          'tenant': $routeParams.tenant
        };
        patch = [];
        for (_i = 0, _len = selected.length; _i < _len; _i++) {
          item = selected[_i];
          patch.push({
            op: 'x-merge',
            path: '/' + item + '/desired/state',
            value: state
          });
        }
        return TenantInstance.patch(params, patch);
      };
      $scope.deleteSelected = function(items) {
        var item, params, patch, _i, _len;
        patch = [];
        params = {
          'tenant': $routeParams.tenant
        };
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          patch.push({
            'op': 'remove',
            'path': '/' + item
          });
        }
        return TenantInstance.patch(params, patch);
      };
    }

    return InstanceListCtrl;

  })());

  module.controller('InstanceDetailCtrl', InstanceDetailCtrl = (function() {
    InstanceDetailCtrl.$inject = ['$scope', '$routeParams', '$modal', 'TenantInstance', 'TenantVolume', 'TenantSwitch', 'TenantSwitchNetwork', 'TenantInstanceVdisk', 'TenantInstanceVnic', 'TenantInstanceVnicAddress', 'TenantVolumeVdisk', 'StoragePool', 'CpuProfile', 'dataContainer'];

    function InstanceDetailCtrl($scope, $routeParams, $modal, TenantInstance, TenantVolume, TenantSwitch, TenantSwitchNetwork, TenantInstanceVdisk, TenantInstanceVnic, TenantInstanceVnicAddress, TenantVolumeVdisk, StoragePool, CpuProfile, dataContainer) {
      var initializeVnicModal, processAddresses, refreshVdiskDict;
      $scope.instanceEditModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/instance-edit-modal.tpl.html',
        show: false
      });
      $scope.vnicEditModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/vnic-edit-modal.tpl.html',
        show: false
      });
      $scope.vdiskListModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/vdisk-list-modal.tpl.html',
        show: false
      });
      TenantInstance.get({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance
      }).$promise.then(function(instance) {
        $scope.instance = instance;
        return dataContainer.registerResource($scope.instance, $scope.instance.desired.uuid);
      });
      CpuProfile.list().$promise.then(function(cp) {
        $scope.cpu_profiles = cp;
        return dataContainer.registerEntity('cpu_profile', $scope.cpu_profiles);
      });
      $scope.instanceEditClose = function(reload) {
        if (reload) {
          TenantInstance.get({
            tenant: $routeParams.tenant,
            instance: $routeParams.instance
          }).$promise.then(function(instance) {
            return $scope.instance = instance;
          });
        }
        return $scope.instanceEditModal.hide();
      };
      $scope.instanceEditOpen = function() {
        var ns, _i, _len, _ref;
        $scope.instance.ns = [];
        _ref = $scope.instance.desired.ns;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ns = _ref[_i];
          $scope.instance.ns.push({
            'value': ns
          });
        }
        return $scope.instanceEditModal.show();
      };
      $scope.addNameserver = function() {
        return $scope.instance.ns.push({
          'value': ''
        });
      };
      $scope.removeNameserver = function(ns) {
        return $scope.instance.ns = $scope.instance.ns.filter(function(item) {
          return item.$$hashKey !== ns.$$hashKey;
        });
      };
      $scope.instanceEditSave = function() {
        var desired, item, ns, params, patch, _i, _len, _ref;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        desired = $scope.instance.desired;
        ns = [];
        _ref = $scope.instance.ns;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          ns.push(item['value']);
        }
        patch = [
          {
            op: 'x-merge',
            path: '/desired',
            value: {
              name: desired.name,
              vcpu: desired.vcpu,
              rcpu: desired.rcpu,
              cpu_profile: desired.cpu_profile,
              boot: desired.boot,
              mem: desired.mem,
              ns: ns,
              state: desired.state
            }
          }
        ];
        TenantInstance.patch(params, patch);
        return $scope.instanceEditClose();
      };
      $scope.instanceSetState = function(state) {
        var params, patch;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        patch = [
          {
            op: 'x-merge',
            path: '/desired/state',
            value: state
          }
        ];
        return TenantInstance.patch(params, patch);
      };
      TenantInstanceVnic.list({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance
      }).$promise.then(function(vnics) {
        $scope.vnics = vnics.sort(function(a, b) {
          return a.desired.index - b.desired.index;
        });
        return dataContainer.registerEntity('vnic', $scope.vnics);
      });
      $scope.vnicIps = TenantInstanceVnic.get({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance,
        vnic: $routeParams.vnic
      });
      $scope.sortVnics = {
        stop: function(e, ui) {
          var i, params, patch, vnic, _i, _len, _ref;
          i = 0;
          patch = [];
          params = {
            'tenant': $routeParams.tenant,
            'instance': $routeParams.instance
          };
          _ref = $scope.vnics;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vnic = _ref[_i];
            patch.push({
              'op': 'x-merge',
              'path': '/' + vnic.desired.uuid + '/desired/index',
              'value': i++
            });
          }
          return TenantInstanceVnic.patch(params, patch);
        }
      };
      initializeVnicModal = function() {
        $scope.$watch('vnic.desired.switch', function(value) {
          return $scope.renewNetworks(value);
        });
        return $scope.vnicEditModal.$promise.then(TenantSwitch.list({
          tenant: $routeParams.tenant
        }).$promise.then(function(ts) {
          $scope.switches = ts;
          if (!$scope.vnic.desired["switch"]) {
            $scope.vnic.desired["switch"] = ts[0].desired.uuid;
          }
          return dataContainer.registerEntity('switch', $scope.switches);
        }));
      };
      $scope.createVnic = function() {
        $scope.vnicEditModal.show();
        $scope.vnic = {
          desired: {
            macaddr: null,
            "switch": null,
            index: null
          },
          addresses: []
        };
        return initializeVnicModal();
      };
      $scope.editVnic = function(vnic) {
        $scope.vnicEditModal.show();
        $scope.vnic = vnic;
        TenantInstanceVnicAddress.list({
          tenant: $routeParams.tenant,
          instance: $routeParams.instance,
          vnic: vnic.desired.uuid
        }).$promise.then(function(addresses) {
          return $scope.vnic.addresses = addresses;
        });
        return initializeVnicModal();
      };
      $scope.vnicEditClose = function() {
        return $scope.vnicEditModal.hide();
      };
      $scope.addAddress = function(networkUUID) {
        if (!networkUUID) {
          networkUUID = $scope.vnic.networks[0].desired.uuid;
        }
        return $scope.vnic.addresses.push({
          desired: {
            ip: '',
            ptr: '',
            network: networkUUID,
            vnic: $scope.vnic.desired.uuid
          }
        });
      };
      $scope.removeAddress = function(address) {
        if (address.desired.uuid) {
          return address.toDelete = true;
        } else {
          return $scope.vnic.addresses = $scope.vnic.addresses.filter(function(item) {
            return item.$$hashKey !== address.$$hashKey;
          });
        }
      };
      $scope.renewNetworks = function(switchUUID) {
        return TenantSwitchNetwork.list({
          tenant: $routeParams.tenant,
          "switch": switchUUID
        }).$promise.then(function(networks) {
          return $scope.vnic.networks = networks;
        });
      };
      $scope.renewAddresses = function(networkUUID) {
        var address, _i, _len, _ref;
        _ref = $scope.vnic.addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          address.desired.network = networkUUID;
        }
        if ($scope.vnic.addresses.length === 0) {
          return $scope.addAddress(networkUUID);
        }
      };
      $scope.vnicEditSave = function() {
        var params, patch, vnic;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance,
          'vnic': $scope.vnic.desired.uuid
        };
        if ($scope.vnic.desired.uuid) {
          patch = JSON.stringify([
            {
              'op': 'x-merge',
              'path': '/desired',
              'value': {
                'macaddr': $scope.vnic.desired.macaddr,
                'switch': $scope.vnic.desired["switch"]
              }
            }
          ]);
          TenantInstanceVnic.patch(params, patch, function(response) {
            return processAddresses(params);
          });
        } else {
          delete params.vnic;
          if (!$scope.vnic.desired.macaddr) {
            delete $scope.vnic.desired.macaddr;
          }
          vnic = new TenantInstanceVnic();
          vnic.desired = $scope.vnic.desired;
          vnic.$save(params, function(response) {
            $scope.vnic.desired.uuid = response.uuids.POST;
            params.vnic = response.uuids.POST;
            return processAddresses(params);
          });
        }
        return $scope.vnicEditClose();
      };
      processAddresses = function(params) {
        var addr_patch, address, i, _i, _len, _ref;
        addr_patch = [];
        i = 0;
        _ref = $scope.vnic.addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          if (!address.desired.ip) {
            delete address.desired.ip;
          }
          if (address.toDelete && address.desired.uuid) {
            addr_patch.push({
              'op': 'remove',
              'path': '/' + address.desired.uuid
            });
          } else if (address.desired.uuid) {
            addr_patch.push({
              'op': 'x-merge',
              'path': '/' + address.desired.uuid + '/desired',
              'value': {
                ip: address.desired.ip,
                ptr: address.desired.ptr,
                network: address.desired.network
              }
            });
          } else {
            addr_patch.push({
              'op': 'add',
              'path': '/addr' + i++,
              'value': {
                'desired': address.desired
              }
            });
          }
        }
        if (addr_patch) {
          return TenantInstanceVnicAddress.patch(params, addr_patch);
        }
      };
      $scope.deleteSelectedVnics = function(items) {
        var item, params, patch, _i, _len;
        patch = [];
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          patch.push({
            'op': 'remove',
            'path': '/' + item
          });
        }
        return TenantInstanceVnic.patch(params, patch);
      };
      TenantInstanceVdisk.list({
        'tenant': $routeParams.tenant,
        'instance': $routeParams.instance
      }).$promise.then(function(vdisks) {
        $scope.vdisks = vdisks.sort(function(a, b) {
          return a.desired.index - b.desired.index;
        });
        dataContainer.registerEntity('vdisk', $scope.vdisks);
        return $scope.$watchCollection('vdisks', function(newVals, oldVals) {
          var item, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = newVals.length; _i < _len; _i++) {
            item = newVals[_i];
            if (jQuery.inArray(item, oldVals) < 0 || newVals.length !== oldVals.length) {
              _results.push(refreshVdiskDict($scope.filteredVolumes));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      });
      TenantVolume.list({
        'tenant': $routeParams.tenant
      }).$promise.then(function(VolumeList) {
        $scope.volumes = VolumeList;
        dataContainer.registerEntity('volume', $scope.volumes);
        return $scope.$watchCollection('volumes', function(newVals, oldVals) {
          var volume, _i, _j, _len, _len1, _results;
          $scope.filteredVolumes = [];
          for (_i = 0, _len = newVals.length; _i < _len; _i++) {
            volume = newVals[_i];
            if (!volume.desired.image) {
              $scope.filteredVolumes.push(volume);
            }
          }
          refreshVdiskDict($scope.filteredVolumes);
          $scope.volumeDict = {};
          _results = [];
          for (_j = 0, _len1 = newVals.length; _j < _len1; _j++) {
            volume = newVals[_j];
            _results.push($scope.volumeDict[volume.desired.uuid] = volume);
          }
          return _results;
        });
      });
      $scope.sortVdisks = {
        stop: function(e, ui) {
          var i, params, patch, vdisk, _i, _len, _ref;
          i = 0;
          patch = [];
          params = {
            'tenant': $routeParams.tenant,
            'instance': $routeParams.instance
          };
          _ref = $scope.vdisks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vdisk = _ref[_i];
            patch.push({
              'op': 'x-merge',
              'path': '/' + vdisk.desired.uuid + '/desired/index',
              'value': i++
            });
          }
          return TenantInstanceVdisk.patch(params, patch);
        }
      };
      $scope.vdiskListClose = function() {
        return $scope.vdiskListModal.hide();
      };
      $scope.vdiskListOpen = function() {
        return $scope.vdiskListModal.show();
      };
      refreshVdiskDict = function(volumes) {
        var uuid, volume, _fn, _i, _len;
        if (!$scope.vdiskDict) {
          $scope.vdiskDict = {};
        }
        if (!volumes) {
          return;
        }
        _fn = function(uuid) {
          return TenantVolumeVdisk.list({
            'tenant': $routeParams.tenant,
            'volume': uuid
          }).$promise.then(function(vdisks) {
            $scope.vdiskDict[uuid] = {
              vdisks: vdisks,
              used_here: false
            };
            return (function(vdisks) {
              var vdisk, _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = vdisks.length; _j < _len1; _j++) {
                vdisk = vdisks[_j];
                if (vdisk.desired.instance === $routeParams.instance) {
                  _results.push($scope.vdiskDict[uuid].used_here = true);
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            })(vdisks);
          });
        };
        for (_i = 0, _len = volumes.length; _i < _len; _i++) {
          volume = volumes[_i];
          uuid = volume.desired.uuid;
          _fn(uuid);
        }
        return $scope.volumeFilter = function(actual, expected) {
          var nameTest, regex, sizeTest;
          regex = new RegExp("^" + expected, 'i');
          nameTest = regex.test($scope.volumeDict[actual].desired.name);
          sizeTest = regex.test($scope.volumeDict[actual].desired.size);
          return nameTest || sizeTest;
        };
      };
      $scope.createVdisk = function(volume) {
        var newVdisk;
        newVdisk = new TenantInstanceVdisk();
        newVdisk.desired = {
          volume: volume.desired.uuid,
          name: volume.desired.name
        };
        return newVdisk.$save({
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        }, function(response) {});
      };
      $scope.deleteSelectedVdisks = function(items) {
        var item, params, patch, _i, _len;
        patch = [];
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          patch.push({
            'op': 'remove',
            'path': '/' + item
          });
        }
        return TenantInstanceVdisk.patch(params, patch);
      };
    }

    return InstanceDetailCtrl;

  })());

  module.controller('InstanceWizardCtrl', InstanceWizardCtrl = (function() {
    InstanceWizardCtrl.$inject = ['$scope', '$routeParams', '$modal', 'TenantInstance', 'TenantSwitchNetwork', 'TenantInstanceVdisk', 'TenantInstanceVnic', 'TenantSwitch', 'Tenant', 'TenantInstanceVnicAddress', 'TenantVolume', 'StoragePool', 'Switch', 'SwitchNetwork', 'CpuProfile', 'TenantAffinityGroup', 'TenantImage', 'Image', 'dataContainer', 'WizardHandler'];

    function InstanceWizardCtrl($scope, $routeParams, $modal, TenantInstance, TenantSwitchNetwork, TenantInstanceVdisk, TenantInstanceVnic, TenantSwitch, Tenant, TenantInstanceVnicAddress, TenantVolume, StoragePool, Switch, SwitchNetwork, CpuProfile, TenantAffinityGroup, TenantImage, Image, dataContainer, WizardHandler) {
      var setDefaultVolumeSize;
      $scope.instance = {
        uuid: '%instance_uuid%',
        selectedVolumes: [],
        vdisks: [],
        vnics: [],
        boot: 'disk',
        ns: [
          {
            'value': ''
          }
        ],
        state: 'running'
      };
      TenantVolume.list({
        'tenant': $routeParams.tenant
      }).$promise.then(function(VolumeList) {
        $scope.volumes = VolumeList;
        dataContainer.registerEntity('volume', $scope.volumes);
        return $scope.$watchCollection('volumes', function(newVals, oldVals) {
          return $scope.filteredVolumes = $scope.volumes.filter(function(item) {
            if (!item.desired.image) {
              return item;
            }
          });
        });
      });
      $scope.$watch('volume.base_image', function(value) {
        return setDefaultVolumeSize(value);
      });
      $scope.$watch('volume.initialize', function(value) {
        if (!value) {
          $scope.volume.size = null;
          return $scope.volume.base_image = null;
        } else {
          $scope.volume.base_image = $scope.images[0].desired.uuid;
          return setDefaultVolumeSize($scope.volume.base_image);
        }
      });
      StoragePool.list().$promise.then(function(items) {
        $scope.storagepools = items;
        return dataContainer.registerEntity('storage_pool', $scope.storagepools);
      });
      Image.list().$promise.then(function(ImageList) {
        $scope.globalImages = ImageList;
        return dataContainer.registerEntity('image', $scope.images);
      });
      TenantImage.list({
        'tenant': $routeParams.tenant
      }).$promise.then(function(ImageList) {
        $scope.images = ImageList;
        dataContainer.registerEntity('image', $scope.images);
        return $scope.$watchCollection('images', function(newVal, oldVal) {
          var image, volume, _i, _len, _ref, _results;
          if (!$scope.imageDict) {
            $scope.imageDict = {};
          }
          if (!$scope.imageSize) {
            $scope.imageSize = {};
          }
          _ref = $scope.volumes;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            volume = _ref[_i];
            _results.push((function() {
              var _j, _len1, _results1;
              _results1 = [];
              for (_j = 0, _len1 = newVal.length; _j < _len1; _j++) {
                image = newVal[_j];
                if (volume.desired.image) {
                  if (!$scope.imageDict[volume.desired.storage_pool]) {
                    $scope.imageDict[volume.desired.storage_pool] = [];
                  }
                  $scope.imageDict[volume.desired.storage_pool].push(volume.desired.image);
                  _results1.push($scope.imageSize[volume.desired.image] = volume.desired.size);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          }
          return _results;
        });
      });
      setDefaultVolumeSize = function(image) {
        if ($scope.volume.size !== 0) {
          if (!!$scope.volume.initialize) {
            return $scope.volume.size = $scope.imageSize[image];
          }
        }
      };
      $scope.addNameserver = function() {
        return $scope.instance.ns.push({
          'value': ''
        });
      };
      $scope.removeNameserver = function(ns) {
        return $scope.instance.ns = $scope.instance.ns.filter(function(item) {
          return item.$$hashKey !== ns.$$hashKey;
        });
      };
      $scope.nextStep = function() {
        return WizardHandler.wizard().next();
      };
      $scope.getFilteredImages = function(storage_pool) {
        var image, rval, _i, _len, _ref, _ref1;
        rval = [];
        _ref = $scope.images;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          image = _ref[_i];
          if (_ref1 = image.desired.uuid, __indexOf.call($scope.imageDict[storage_pool], _ref1) >= 0) {
            rval.push(image);
          }
        }
        return rval.concat($scope.globalImages);
      };
      CpuProfile.list().$promise.then(function(items) {
        $scope.cpu_profiles = items;
        $scope.instance.cpu_profile = items[0].desired.uuid;
        return dataContainer.registerEntity('cpu_profile', $scope.cpu_profiles);
      });
      TenantSwitch.list({
        tenant: $routeParams.tenant
      }).$promise.then(function(switches) {
        $scope.switches = switches;
        Switch.list().$promise.then(function(publicSwitches) {
          return $scope.switches = $scope.switches.concat(publicSwitches);
        });
        return dataContainer.registerEntity('switch', $scope.switches);
      });
      $scope.wizardVdiskListModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/wizard-vdisk-list-modal.tpl.html',
        show: false
      });
      $scope.wizardVdiskListClose = function() {
        return $scope.wizardVdiskListModal.hide();
      };
      $scope.volumeIterator = 0;
      $scope.wizardVdiskListOpen = function() {
        $scope.volume = {};
        return $scope.wizardVdiskListModal.show();
      };
      $scope.sortVdisks = {
        stop: function(e, ui) {
          var i, vdisk, vdisks, _i, _len, _ref;
          i = 0;
          vdisks = [];
          _ref = $scope.instance.vdisks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vdisk = _ref[_i];
            vdisk.desired.index = i++;
            vdisks.push(vdisk);
          }
          return $scope.instance.vdisks = vdisks;
        }
      };
      TenantAffinityGroup.list({
        tenant: $routeParams.tenant
      }).$promise.then(function(ag) {
        $scope.affinity_groups = ag;
        return dataContainer.registerEntity('affinity_group', $scope.affinity_groups);
      });
      $scope.removeVnic = function(vnic) {
        return $scope.instance['vnics'] = $scope.instance['vnics'].filter(function(item) {
          return item.$$hashKey !== vnic.$$hashKey;
        });
      };
      $scope.addVnic = function() {
        var c, defSwitch;
        defSwitch = null;
        if ($scope.switches) {
          defSwitch = $scope.switches[0].desired.uuid;
        }
        c = $scope.instance.vnics.push({
          desired: {
            "switch": defSwitch,
            addresses: [],
            index: $scope.instance.vnics.length
          }
        });
        return $scope.$watch('instance.vnics[' + (c - 1) + '].desired.switch', function(value) {
          return $scope.renewNetworks(value, c - 1);
        });
      };
      $scope.addVnic();
      $scope.sortVnics = {
        stop: function(e, ui) {
          var i, vnic, vnics, _i, _len, _ref;
          i = 0;
          vnics = [];
          _ref = $scope.instance.vnics;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vnic = _ref[_i];
            vnic.desired.index = i++;
            vnics.push(vnic);
          }
          return $scope.instance.vnics = vnics;
        }
      };
      $scope.finishedWizard = function() {
        return console.log("Dokonceno!");
      };
      $scope.renewAddresses = function(networkUUID, index) {
        var address, _i, _len, _ref;
        _ref = $scope.instance.vnics[index].desired.addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          address.desired.network = networkUUID;
        }
        if ($scope.instance.vnics[index].desired.addresses.length === 0) {
          return $scope.addAddress(networkUUID, $scope.instance.vnics[index]);
        }
      };
      $scope.addAddress = function(networkUUID, vnic) {
        var k;
        k = jQuery.inArray(vnic, $scope.instance.vnics);
        return $scope.instance.vnics[k].desired.addresses.push({
          desired: {
            ip: null,
            ptr: null,
            network: networkUUID
          }
        });
      };
      $scope.removeAddress = function(address, vnic) {
        var k;
        k = jQuery.inArray(vnic, $scope.instance.vnics);
        return $scope.instance.vnics[k].desired.addresses = $scope.instance.vnics[k].desired.addresses.filter(function(item) {
          return item.$$hashKey !== address.$$hashKey;
        });
      };
      $scope.renewNetworks = function(switchUUID, index) {
        return TenantSwitchNetwork.list({
          tenant: $routeParams.tenant,
          "switch": switchUUID
        }).$promise.then(function(networks) {
          console.log(networks);
          SwitchNetwork.list({
            "switch": switchUUID
          }).$promise.then(function(publicNetworks) {
            return networks.concat(publicNetworks);
          });
          $scope.instance.vnics[index].networks = networks;
          return $scope.renewAddresses(networks[0].desired.uuid, index);
        });
      };
      $scope.appendVolume = function(desired) {
        var volume;
        volume = {
          desired: desired,
          current: {}
        };
        volume.desired.state = 'present';
        volume.to_create = true;
        $scope.volumeIterator++;
        volume.desired.uuid = '%volume-' + $scope.volumeIterator + '_uuid%';
        $scope.assignVolume(volume);
        return $scope.wizardVdiskListClose();
      };
      $scope.assignVolume = function(volume) {
        volume.selected = true;
        return $scope.instance['vdisks'].push({
          desired: {
            volume: volume.desired.uuid,
            instance: $scope.instance.uuid,
            index: $scope.instance['vdisks'].length + 1
          },
          volume: volume
        });
      };
      $scope.unassignVolume = function(volume) {
        var item, _i, _len, _ref;
        _ref = $scope.volumes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (volume.desired.uuid === item.desired.uuid) {
            item.selected = false;
          }
        }
        return $scope.instance['vdisks'] = $scope.instance['vdisks'].filter(function(item) {
          return item.volume.desired.uuid !== volume.desired.uuid;
        });
      };
      $scope.createInstance = function() {
        var address, addresses, instancePatch, item, ns, params, patch, vdisk, vdisks, vnic, vnics, volumes, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        params = {
          'tenant': $routeParams.tenant
        };
        patch = [];
        volumes = {};
        vdisks = {};
        _ref = $scope.instance.vdisks;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vdisk = _ref[_i];
          if (vdisk.volume.to_create) {
            volumes[vdisk.volume.desired.uuid] = {
              desired: vdisk.volume.desired
            };
          }
          vdisks[vdisk.$$hashKey] = {
            desired: vdisk.desired
          };
        }
        vnics = {};
        _ref1 = $scope.instance.vnics;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          vnic = _ref1[_j];
          addresses = {};
          _ref2 = vnic.desired.addresses;
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            address = _ref2[_k];
            addresses[address.$$hashKey] = {
              desired: address.desired
            };
          }
          vnics[vnic.$$hashKey] = {
            desired: {
              "switch": vnic.desired["switch"],
              index: vnic.desired.index,
              uuid: vnic.$$hashKey
            },
            children: {
              address: addresses
            }
          };
        }
        instancePatch = {
          op: 'x-merge',
          path: '/',
          value: {
            children: {
              instance: {},
              volume: volumes
            }
          }
        };
        ns = [];
        _ref3 = $scope.instance.ns;
        for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
          item = _ref3[_l];
          ns.push(item.value);
        }
        instancePatch['value']['children']['instance'][$scope.instance.uuid] = {
          desired: {
            name: $scope.instance.name,
            vcpu: $scope.instance.vcpu,
            rcpu: $scope.instance.rcpu,
            mem: $scope.instance.mem,
            boot: $scope.instance.boot,
            state: $scope.instance.state,
            ns: ns,
            cpu_profile: $scope.instance.cpu_profile
          },
          children: {
            vdisk: vdisks,
            vnic: vnics
          }
        };
        patch.push(instancePatch);
        return Tenant.patch(params, patch);
      };
    }

    return InstanceWizardCtrl;

  })());

}).call(this);
