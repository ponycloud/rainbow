// Generated by CoffeeScript 1.7.1
(function() {
  var InstanceDetailCtrl, InstanceListCtrl, InstanceWizardCtrl, module;

  module = angular.module('tenantInstance', ['rainbowServices']);

  module.config([
    '$routeProvider', function($routeProvider) {
      $routeProvider.when('/:tenant/instance', {
        templateUrl: 'tenant/instance/instance-list.tpl.html',
        controller: 'InstanceListCtrl'
      });
      $routeProvider.when('/:tenant/instance/create', {
        templateUrl: 'tenant/instance/instance-wizard.tpl.html',
        controller: 'InstanceWizardCtrl'
      });
      return $routeProvider.when('/:tenant/instance/:instance', {
        templateUrl: 'tenant/instance/instance-detail.tpl.html',
        controller: 'InstanceDetailCtrl'
      });
    }
  ]);

  module.controller('InstanceListCtrl', InstanceListCtrl = (function() {
    InstanceListCtrl.inject = ['$scope', '$routeParams', 'TenantInstance', 'dataContainer'];

    function InstanceListCtrl($scope, $routeParams, TenantInstance, dataContainer, $modal) {
      var list;
      list = TenantInstance.list({
        tenant: $routeParams.tenant
      });
      list.$promise.then(function(i) {
        $scope.instances = i;
        return dataContainer.registerEntity('instance', $scope.instances);
      });
    }

    return InstanceListCtrl;

  })());

  module.controller('InstanceDetailCtrl', InstanceDetailCtrl = (function() {
    InstanceDetailCtrl.$inject = ['$scope', '$routeParams', '$modal', 'TenantInstance', 'TenantVolume', 'TenantSwitch', 'TenantSwitchNetwork', 'TenantInstanceVdisk', 'TenantInstanceVnic', 'TenantInstanceVnicAddress', 'TenantVolumeVdisk', 'StoragePool', 'CpuProfile', 'dataContainer'];

    function InstanceDetailCtrl($scope, $routeParams, $modal, TenantInstance, TenantVolume, TenantSwitch, TenantSwitchNetwork, TenantInstanceVdisk, TenantInstanceVnic, TenantInstanceVnicAddress, TenantVolumeVdisk, StoragePool, CpuProfile, dataContainer) {
      var initializeVnicModal, processAddresses, refreshVdiskDict;
      $scope.instanceEditModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/instance-edit-modal.tpl.html',
        show: false
      });
      $scope.vnicEditModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/vnic-edit-modal.tpl.html',
        show: false
      });
      $scope.vdiskListModal = $modal({
        keyboard: true,
        scope: $scope,
        template: 'tenant/instance/vdisk-list-modal.tpl.html',
        show: false
      });
      TenantInstance.get({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance
      }).$promise.then(function(instance) {
        $scope.instance = instance;
        return dataContainer.registerResource($scope.instance, $scope.instance.desired.uuid);
      });
      CpuProfile.list().$promise.then(function(cp) {
        $scope.cpu_profiles = cp;
        return dataContainer.registerEntity('cpu_profile', $scope.cpu_profiles);
      });
      $scope.instanceEditClose = function(reload) {
        if (reload) {
          TenantInstance.get({
            tenant: $routeParams.tenant,
            instance: $routeParams.instance
          }).$promise.then(function(instance) {
            return $scope.instance = instance;
          });
        }
        return $scope.instanceEditModal.hide();
      };
      $scope.instanceEditOpen = function() {
        return $scope.instanceEditModal.show();
      };
      $scope.instanceEditSave = function() {
        var desired, params, patch;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        desired = $scope.instance.desired;
        patch = [
          {
            op: 'x-merge',
            path: '/desired',
            value: {
              name: desired.name,
              vcpu: desired.vcpu,
              rcpu: desired.rcpu,
              cpu_profile: desired.cpu_profile,
              boot: desired.boot,
              mem: desired.mem
            }
          }
        ];
        TenantInstance.patch(params, patch);
        return $scope.instanceEditClose();
      };
      $scope.instanceSetState = function(state) {
        var params, patch;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        patch = [
          {
            op: 'x-merge',
            path: '/desired/state',
            value: state
          }
        ];
        return TenantInstance.patch(params, patch);
      };
      TenantInstanceVnic.list({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance
      }).$promise.then(function(vnics) {
        $scope.vnics = vnics;
        return dataContainer.registerEntity('vnic', $scope.vnics);
      });
      $scope.vnicIps = TenantInstanceVnic.get({
        tenant: $routeParams.tenant,
        instance: $routeParams.instance,
        vnic: $routeParams.vnic
      });
      $scope.sortVnics = {
        stop: function(e, ui) {
          var i, params, patch, vnic, _i, _len, _ref;
          i = 0;
          patch = [];
          params = {
            'tenant': $routeParams.tenant,
            'instance': $routeParams.instance
          };
          _ref = $scope.vnics;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vnic = _ref[_i];
            patch.push({
              'op': 'x-merge',
              'path': '/' + vnic.desired.uuid + '/desired/index',
              'value': i++
            });
          }
          return TenantInstanceVnic.patch(params, patch);
        }
      };
      initializeVnicModal = function() {
        $scope.$watch('vnic.desired.switch', function(value) {
          return $scope.renewNetworks(value);
        });
        return $scope.vnicEditModal.$promise.then(TenantSwitch.list({
          tenant: $routeParams.tenant
        }).$promise.then(function(ts) {
          $scope.switches = ts;
          if (!$scope.vnic.desired["switch"]) {
            $scope.vnic.desired["switch"] = ts[0].desired.uuid;
          }
          return dataContainer.registerEntity('switch', $scope.switches);
        }));
      };
      $scope.createVnic = function() {
        $scope.vnicEditModal.show();
        $scope.vnic = {
          'desired': {
            'macaddr': null,
            'switch': null,
            'index': null
          },
          'addresses': []
        };
        return initializeVnicModal();
      };
      $scope.editVnic = function(vnic) {
        $scope.vnicEditModal.show();
        $scope.vnic = vnic;
        TenantInstanceVnicAddress.list({
          tenant: $routeParams.tenant,
          instance: $routeParams.instance,
          vnic: vnic.desired.uuid
        }).$promise.then(function(addresses) {
          return $scope.vnic.addresses = addresses;
        });
        return initializeVnicModal();
      };
      $scope.vnicEditClose = function() {
        return $scope.vnicEditModal.hide();
      };
      $scope.addAddress = function(networkUUID) {
        if (!networkUUID) {
          networkUUID = $scope.vnic.networks[0].desired.uuid;
        }
        return $scope.vnic.addresses.push({
          'desired': {
            'ip': '',
            'ptr': '',
            'network': networkUUID,
            'vnic': $scope.vnic.desired.uuid
          }
        });
      };
      $scope.removeAddress = function(address) {
        if (address.desired.uuid) {
          return address.toDelete = true;
        } else {
          return $scope.vnic.addresses = $scope.vnic.addresses.filter(function(item) {
            return item.$$hashKey !== address.$$hashKey;
          });
        }
      };
      $scope.renewNetworks = function(switchUUID) {
        return TenantSwitchNetwork.list({
          tenant: $routeParams.tenant,
          "switch": switchUUID
        }).$promise.then(function(networks) {
          return $scope.vnic.networks = networks;
        });
      };
      $scope.renewAddresses = function(networkUUID) {
        var address, _i, _len, _ref;
        _ref = $scope.vnic.addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          address.desired.network = networkUUID;
        }
        if ($scope.vnic.addresses.length === 0) {
          return $scope.addAddress(networkUUID);
        }
      };
      $scope.vnicEditSave = function() {
        var params, patch, vnic;
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance,
          'vnic': $scope.vnic.desired.uuid
        };
        if ($scope.vnic.desired.uuid) {
          patch = JSON.stringify([
            {
              'op': 'x-merge',
              'path': '/desired',
              'value': {
                'macaddr': $scope.vnic.desired.macaddr,
                'switch': $scope.vnic.desired["switch"]
              }
            }
          ]);
          TenantInstanceVnic.patch(params, patch, function(response) {
            return processAddresses(params);
          });
        } else {
          delete params.vnic;
          if (!$scope.vnic.desired.macaddr) {
            delete $scope.vnic.desired.macaddr;
          }
          vnic = new TenantInstanceVnic();
          vnic.desired = $scope.vnic.desired;
          vnic.$save(params, function(response) {
            $scope.vnic.desired.uuid = response.uuids.POST;
            params.vnic = response.uuids.POST;
            return processAddresses(params);
          });
        }
        return $scope.vnicEditClose();
      };
      processAddresses = function(params) {
        var addr_patch, address, i, _i, _len, _ref;
        addr_patch = [];
        i = 0;
        _ref = $scope.vnic.addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          if (!address.desired.ip) {
            delete address.desired.ip;
          }
          if (address.toDelete && address.desired.uuid) {
            addr_patch.push({
              'op': 'remove',
              'path': '/' + address.desired.uuid
            });
          } else if (address.desired.uuid) {
            addr_patch.push({
              'op': 'x-merge',
              'path': '/' + address.desired.uuid + '/desired',
              'value': {
                'ip': address.desired.ip,
                'ptr': address.desired.ptr,
                'network': address.desired.network
              }
            });
          } else {
            addr_patch.push({
              'op': 'add',
              'path': '/addr' + i++,
              'value': {
                'desired': address.desired
              }
            });
          }
        }
        if (addr_patch) {
          return TenantInstanceVnicAddress.patch(params, addr_patch);
        }
      };
      $scope.deleteSelectedVnics = function(items) {
        var item, params, patch, _i, _len;
        patch = [];
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          patch.push({
            'op': 'remove',
            'path': '/' + item
          });
        }
        return TenantInstanceVnic.patch(params, patch);
      };
      TenantInstanceVdisk.list({
        'tenant': $routeParams.tenant,
        'instance': $routeParams.instance
      }).$promise.then(function(vdisks) {
        $scope.vdisks = vdisks;
        dataContainer.registerEntity('vdisk', $scope.vdisks);
        return $scope.$watchCollection('vdisks', function(newVals, oldVals) {
          var item, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = newVals.length; _i < _len; _i++) {
            item = newVals[_i];
            if (jQuery.inArray(item, oldVals) < 0 || newVals.length !== oldVals.length) {
              _results.push(refreshVdiskDict($scope.filteredVolumes));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      });
      TenantVolume.list({
        'tenant': $routeParams.tenant
      }).$promise.then(function(VolumeList) {
        $scope.volumes = VolumeList;
        dataContainer.registerEntity('volume', $scope.volumes);
        return $scope.$watchCollection('volumes', function(newVals, oldVals) {
          var volume, _i, _j, _len, _len1, _results;
          $scope.filteredVolumes = [];
          for (_i = 0, _len = newVals.length; _i < _len; _i++) {
            volume = newVals[_i];
            if (!volume.desired.image) {
              $scope.filteredVolumes.push(volume);
            }
          }
          refreshVdiskDict($scope.filteredVolumes);
          $scope.volumeDict = {};
          _results = [];
          for (_j = 0, _len1 = newVals.length; _j < _len1; _j++) {
            volume = newVals[_j];
            _results.push($scope.volumeDict[volume.desired.uuid] = volume);
          }
          return _results;
        });
      });
      $scope.sortVdisks = {
        stop: function(e, ui) {
          var i, params, patch, vdisk, _i, _len, _ref;
          i = 0;
          patch = [];
          params = {
            'tenant': $routeParams.tenant,
            'instance': $routeParams.instance
          };
          _ref = $scope.vdisks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            vdisk = _ref[_i];
            patch.push({
              'op': 'x-merge',
              'path': '/' + vdisk.desired.uuid + '/desired/index',
              'value': i++
            });
          }
          return TenantInstanceVdisk.patch(params, patch);
        }
      };
      $scope.vdiskListClose = function() {
        return $scope.vdiskListModal.hide();
      };
      $scope.vdiskListOpen = function() {
        return $scope.vdiskListModal.show();
      };
      refreshVdiskDict = function(volumes) {
        var uuid, volume, _fn, _i, _len;
        if (!$scope.vdiskDict) {
          $scope.vdiskDict = {};
        }
        if (!volumes) {
          return;
        }
        _fn = function(uuid) {
          return TenantVolumeVdisk.list({
            'tenant': $routeParams.tenant,
            'volume': uuid
          }).$promise.then(function(vdisks) {
            $scope.vdiskDict[uuid] = {
              vdisks: vdisks,
              used_here: false
            };
            return (function(vdisks) {
              var vdisk, _j, _len1, _results;
              _results = [];
              for (_j = 0, _len1 = vdisks.length; _j < _len1; _j++) {
                vdisk = vdisks[_j];
                if (vdisk.desired.instance === $routeParams.instance) {
                  _results.push($scope.vdiskDict[uuid].used_here = true);
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            })(vdisks);
          });
        };
        for (_i = 0, _len = volumes.length; _i < _len; _i++) {
          volume = volumes[_i];
          uuid = volume.desired.uuid;
          _fn(uuid);
        }
        console.log($scope.vdiskDict);
        return $scope.volumeFilter = function(actual, expected) {
          var nameTest, regex, sizeTest;
          regex = new RegExp("^" + expected, 'i');
          nameTest = regex.test($scope.volumeDict[actual].desired.name);
          sizeTest = regex.test($scope.volumeDict[actual].desired.size);
          return nameTest || sizeTest;
        };
      };
      $scope.createVdisk = function(volume) {
        var newVdisk;
        newVdisk = new TenantInstanceVdisk();
        newVdisk.desired = {
          'volume': volume.desired.uuid,
          'name': volume.desired.name
        };
        return newVdisk.$save({
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        }, function(response) {});
      };
      $scope.deleteSelectedVdisks = function(items) {
        var item, params, patch, _i, _len;
        patch = [];
        params = {
          'tenant': $routeParams.tenant,
          'instance': $routeParams.instance
        };
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          patch.push({
            'op': 'remove',
            'path': '/' + item
          });
        }
        return TenantInstanceVdisk.patch(params, patch);
      };
    }

    return InstanceDetailCtrl;

  })());

  module.controller('InstanceWizardCtrl', InstanceWizardCtrl = (function() {
    InstanceWizardCtrl.$inject = ['$scope', '$routeParams', 'TenantInstance', 'TenantSwitchNetwork', 'TenantInstanceVdisk', 'TenantInstanceVnic', 'TenantSwitch', 'TenantInstanceVnicAddress', 'TenantVolume', 'StoragePool', 'CpuProfile', 'TenantAffinityGroup', 'dataContainer'];

    function InstanceWizardCtrl($scope, $routeParams, TenantInstance, TenantSwitchNetwork, TenantInstanceVdisk, TenantInstanceVnic, TenantSwitch, TenantInstanceVnicAddress, TenantVolume, StoragePool, CpuProfile, TenantAffinityGroup, dataContainer) {
      $scope.instance = {
        'selectedVolumes': [],
        'vdisks': [],
        'vnics': [],
        'boot': 'disk',
        'ns': []
      };
      CpuProfile.list().$promise.then(function(cp) {
        $scope.cpu_profiles = cp;
        $scope.instance.cpu_profile = cp[0].desired.uuid;
        return dataContainer.registerEntity('cpu_profile', $scope.cpu_profiles);
      });
      TenantSwitch.list({
        tenant: $routeParams.tenant
      }).$promise.then(function(ts) {
        $scope.switches = ts;
        $scope.instance.vnics[0]["switch"] = ts[0].desired.uuid;
        return dataContainer.registerEntity('switch', $scope.switches);
      });
      TenantVolume.list({
        'tenant': $routeParams.tenant
      }).$promise.then(function(VolumeList) {
        $scope.volumes = VolumeList;
        dataContainer.registerEntity('volume', $scope.volumes);
        return $scope.$watchCollection('volumes', function(newVals, oldVals) {
          return $scope.filteredVolumes = $scope.volumes.filter(function(item) {
            if (!item.desired.image) {
              return item;
            }
          });
        });
      });
      TenantAffinityGroup.list({
        tenant: $routeParams.tenant
      }).$promise.then(function(ag) {
        $scope.affinity_groups = ag;
        return dataContainer.registerEntity('affinity_group', $scope.affinity_groups);
      });
      $scope.removeVnic = function(vnic) {
        return $scope.instance['vnics'] = $scope.instance['vnics'].filter(function(item) {
          return item.$$hashKey !== vnic.$$hashKey;
        });
      };
      $scope.addVnic = function() {
        var c, defSwitch;
        defSwitch = null;
        if ($scope.switches) {
          defSwitch = $scope.switches[0].desired.uuid;
        }
        c = $scope.instance.vnics.push({
          'switch': defSwitch,
          'network': null,
          'addresses': []
        });
        $scope.$watch('instance.vnics[' + (c - 1) + '].switch', function(value) {
          return $scope.renewNetworks(value, c - 1);
        });
        return $scope.$watch('instance.vnics[' + (c - 1) + '].network', function(value) {
          return $scope.renewAddresses(value, c - 1);
        });
      };
      $scope.addVnic();
      $scope.finishedWizard = function() {
        return console.log("Dokonceno!");
      };
      $scope.renewAddresses = function(networkUUID, index) {
        var address, _i, _len, _ref;
        _ref = $scope.instance.vnics[index].addresses;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          address = _ref[_i];
          address.desired.network = networkUUID;
        }
        if ($scope.instance.vnics[index].addresses.length === 0) {
          return $scope.addAddress(networkUUID, $scope.instance.vnics[index]);
        }
      };
      $scope.addAddress = function(networkUUID, vnic) {
        var k;
        k = jQuery.inArray(vnic, $scope.instance.vnics);
        return $scope.instance.vnics[k].addresses.push({
          'desired': {
            'ip': '',
            'ptr': '',
            'network': networkUUID
          }
        });
      };
      $scope.removeAddress = function(address, vnic) {
        var k;
        k = jQuery.inArray(vnic, $scope.instance.vnics);
        return $scope.instance.vnics[k].addresses = $scope.instance.vnics[k].addresses.filter(function(item) {
          return item.$$hashKey !== address.$$hashKey;
        });
      };
      $scope.renewNetworks = function(switchUUID, index) {
        return TenantSwitchNetwork.list({
          tenant: $routeParams.tenant,
          "switch": switchUUID
        }).$promise.then(function(networks) {
          $scope.instance.vnics[index].networks = networks;
          return $scope.renewAddresses(networks[0].desired.uuid, index);
        });
      };
      $scope.assignVolume = function(volume) {
        volume.selected = true;
        return $scope.instance['vdisks'].push({
          'desired': {
            'volume': volume.desired.uuid,
            'instance': '%instance_uuid%',
            'index': $scope.instance['vdisks'].length + 1
          },
          'volume': volume
        });
      };
      $scope.unassignVolume = function(volume) {
        var item, _i, _len, _ref;
        _ref = $scope.volumes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (volume.desired.uuid === item.desired.uuid) {
            item.selected = false;
          }
        }
        return $scope.instance['vdisks'] = $scope.instance['vdisks'].filter(function(item) {
          return item.volume.desired.uuid !== volume.desired.uuid;
        });
      };
    }

    return InstanceWizardCtrl;

  })());

}).call(this);
